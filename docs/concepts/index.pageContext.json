{"pageId":"/pages/docs","routeParams":{"splat":"concepts"},"data":{"doc":{"path":"/docs/concepts","filePath":"/home/runner/work/isolated-workers/isolated-workers/docs/concepts/index.md","title":"Core Concepts","description":"Understanding the architecture and mental model of isolated-workers","nav":{"section":"Concepts","order":0}},"segments":[{"type":"html","html":"<h1>Core Concepts</h1>\n<p>This guide explains the fundamental concepts and architecture of isolated-workers. Understanding these concepts will help you design effective worker-based systems and troubleshoot issues when they arise.</p>\n<h2>What is isolated-workers?</h2>\n<p>isolated-workers is a type-safe library for spawning and managing worker processes in Node.js. It provides a clean abstraction for running code in separate processes while maintaining full TypeScript type safety for the messages exchanged between them.</p>\n<p>The library extracts proven patterns from Nx's isolated plugin architecture, bringing battle-tested solutions for:</p>\n<ul>\n<li><strong>Process Isolation</strong>: Run untrusted or resource-intensive code in separate processes</li>\n<li><strong>Type-Safe IPC</strong>: Full TypeScript inference for messages crossing process boundaries</li>\n<li><strong>Lifecycle Management</strong>: Spawn, connect, monitor, and gracefully shutdown workers</li>\n<li><strong>Cross-Platform Support</strong>: Works on Unix (domain sockets) and Windows (named pipes)</li>\n</ul>\n<h2>The Worker Pattern</h2>\n<h3>Host and Worker Architecture</h3>\n<p>isolated-workers uses a host/worker architecture where two Node.js processes communicate over a socket connection:</p>"},{"type":"code-block","language":"text","content":"┌─────────────────────┐          ┌─────────────────────┐\n│                     │          │                     │\n│        HOST         │  socket  │       WORKER        │\n│    (main process)   │◄────────►│   (child process)   │\n│                     │          │                     │\n└─────────────────────┘          └─────────────────────┘","highlightedHtml":"<pre class=\"shiki github-dark\" style=\"background-color:#00000000;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span>┌─────────────────────┐          ┌─────────────────────┐</span></span>\n<span class=\"line\"><span>│                     │          │                     │</span></span>\n<span class=\"line\"><span>│        HOST         │  socket  │       WORKER        │</span></span>\n<span class=\"line\"><span>│    (main process)   │◄────────►│   (child process)   │</span></span>\n<span class=\"line\"><span>│                     │          │                     │</span></span>\n<span class=\"line\"><span>└─────────────────────┘          └─────────────────────┘</span></span></code></pre>"},{"type":"html","html":"<p><strong>Host Process</strong>: Your main application that spawns and controls workers. The host sends requests and receives results.</p>\n<p><strong>Worker Process</strong>: A separate Node.js process that handles requests independently. Workers have their own memory space, event loop, and can crash without affecting the host.</p>\n<h3>Why Process Isolation Matters</h3>\n<p>Process isolation provides several important benefits:</p>\n<ol>\n<li>\n<p><strong>Fault Isolation</strong>: If a worker crashes due to unhandled exceptions or out-of-memory errors, the host process continues running. You can restart workers as needed.</p>\n</li>\n<li>\n<p><strong>Resource Isolation</strong>: Workers have their own memory heap. Memory-intensive operations in a worker do not affect the host's memory usage or garbage collection.</p>\n</li>\n<li>\n<p><strong>Security Boundaries</strong>: Workers run in separate processes with their own context. This provides a natural boundary for running less-trusted code.</p>\n</li>\n<li>\n<p><strong>Parallel Execution</strong>: Unlike Node.js worker threads, separate processes can fully utilize multiple CPU cores for CPU-bound work without sharing the event loop.</p>\n</li>\n<li>\n<p><strong>Clean State</strong>: Each worker starts fresh. There is no shared mutable state between workers, eliminating entire categories of concurrency bugs.</p>\n</li>\n</ol>\n<h2>How IPC Works</h2>\n<h3>Communication Channels</h3>\n<p>isolated-workers uses OS-native communication primitives for inter-process communication (IPC):</p>\n<p><strong>On Unix-like Systems (Linux, macOS)</strong>:</p>\n<ul>\n<li>Uses Unix domain sockets</li>\n<li>Socket file created in the filesystem (typically in <code class=\"inline-code\">/tmp</code>)</li>\n<li>Provides bidirectional, stream-based communication</li>\n<li>Highest performance for local IPC</li>\n</ul>\n<p><strong>On Windows</strong>:</p>\n<ul>\n<li>Uses named pipes (<code class=\"inline-code\">\\\\.\\pipe\\...</code>)</li>\n<li>Native Windows IPC mechanism</li>\n<li>Same bidirectional semantics as Unix sockets</li>\n</ul>\n<p>The library automatically detects the platform and uses the appropriate mechanism. Your code remains unchanged across platforms.</p>\n<h3>Message Serialization</h3>\n<p>Messages between host and worker must be serialized since they cross process boundaries. By default, isolated-workers uses JSON serialization, which handles:</p>\n<ul>\n<li>Primitive types (strings, numbers, booleans, null)</li>\n<li>Arrays and plain objects</li>\n<li>Nested structures</li>\n</ul>\n<p>Messages are delimited with a terminator character (default: '\\n') for streaming.</p>\n<p>For special requirements, you can provide custom serializers that support binary formats, compression, or encryption.</p>\n<p><strong>Error Serialization</strong>: Errors receive special handling. When an error is thrown in a worker, isolated-workers serializes the error message, name, stack trace, and common properties like <code class=\"inline-code\">code</code>. The error is then reconstructed on the host side, preserving debugging information.</p>\n<h3>Transaction IDs</h3>\n<p>Every request/response pair is linked by a transaction ID. This enables:</p>\n<ul>\n<li><strong>Multiple In-Flight Requests</strong>: Send several requests to a worker without waiting for each response</li>\n<li><strong>Response Correlation</strong>: The host matches each response to its original request</li>\n<li><strong>Timeout Tracking</strong>: Each transaction can have its own timeout</li>\n</ul>\n<p>When you call a method on a worker, the library generates a unique transaction ID (using <code class=\"inline-code\">crypto.randomUUID()</code>), attaches it to the message, and stores a promise resolver. When the worker responds with the same transaction ID, the promise resolves.</p>\n<h2>Type-Safe Messaging</h2>\n<h3>The DefineMessages Pattern</h3>\n<p>The core of isolated-workers' type safety is the <code class=\"inline-code\"><a class=\"code-link\" href=\"/isolated-workers/isolated-workers/api/define-messages\">DefineMessages</a></code> pattern. Instead of defining messages as loose types, you define them in a single structured definition:</p>"},{"type":"code-block","language":"text","content":"DefineMessages<{\n  [messageType]: {\n    payload: [what you send];\n    result?: [what you receive back];\n  };\n}>","highlightedHtml":"<pre class=\"shiki github-dark\" style=\"background-color:#00000000;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span><a href=\"/isolated-workers/api/define-messages\" class=\"code-link\" title=\"View DefineMessages documentation\">DefineMessages</a>&#x3C;{</span></span>\n<span class=\"line\"><span>  [messageType]: {</span></span>\n<span class=\"line\"><span>    payload: [what you send];</span></span>\n<span class=\"line\"><span>    result?: [what you receive back];</span></span>\n<span class=\"line\"><span>  };</span></span>\n<span class=\"line\"><span>}></span></span></code></pre>"},{"type":"html","html":"<p>This pattern provides:</p>\n<ul>\n<li><strong>Compile-Time Checking</strong>: TypeScript verifies that you send the correct payload type and expect the correct result type</li>\n<li><strong>Exhaustive Handlers</strong>: The worker must implement a handler for every message type</li>\n<li><strong>Automatic Inference</strong>: The library infers types throughout - no manual type annotations needed</li>\n</ul>\n<h3>Message and Result Types</h3>\n<p>Each message type can have:</p>\n<ul>\n<li><strong>payload</strong>: The data sent with the message (required)</li>\n<li><strong>result</strong>: The data returned in response (optional)</li>\n</ul>\n<p>Messages without a <code class=\"inline-code\">result</code> are \"fire-and-forget\" - the host sends them but does not wait for or expect a response. Messages with a <code class=\"inline-code\">result</code> are request/response pairs where the host awaits a typed response.</p>\n<h3>Type Extraction Helpers</h3>\n<p>The library provides helper types to extract specific parts of your message definitions:</p>\n<ul>\n<li><strong>MessageOf</strong>: Extract the full message type for a specific message name</li>\n<li><strong>ResultOf</strong>: Extract the result type for a specific message name</li>\n<li><strong>WithResult</strong>: Filter to only message types that have results</li>\n<li><strong>AllMessages</strong>: Union of all message types</li>\n<li><strong>AllResults</strong>: Union of all result types</li>\n</ul>\n<p>These helpers are used internally and are also available for advanced use cases where you need to reference specific message types.</p>\n<h3>PayloadOf and ResultPayloadOf</h3>\n<p>Extract just the payload or result payload types without the wrapper:</p>"},{"type":"code-block","language":"typescript","content":"import { PayloadOf, ResultPayloadOf } from 'isolated-workers';\n\ntype LoadPayload = PayloadOf<Messages, 'load'>;\n// { config: string }\n\ntype LoadResultPayload = ResultPayloadOf<Messages, 'load'>;\n// { loaded: true }","highlightedHtml":"<pre class=\"shiki github-dark\" style=\"background-color:#00000000;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { <a href=\"/isolated-workers/api/payload-of\" class=\"code-link\" title=\"View PayloadOf documentation\">PayloadOf</a>, <a href=\"/isolated-workers/api/result-payload-of\" class=\"code-link\" title=\"View ResultPayloadOf documentation\">ResultPayloadOf</a> } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'isolated-workers'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LoadPayload</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> <a href=\"/isolated-workers/api/payload-of\" class=\"code-link\" title=\"View PayloadOf documentation\">PayloadOf</a></span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Messages</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'load'</span><span style=\"color:#E1E4E8\">>;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// { config: string }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LoadResultPayload</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> <a href=\"/isolated-workers/api/result-payload-of\" class=\"code-link\" title=\"View ResultPayloadOf documentation\">ResultPayloadOf</a></span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Messages</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'load'</span><span style=\"color:#E1E4E8\">>;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// { loaded: true }</span></span></code></pre>"},{"type":"html","html":"<h3>MessageResult</h3>\n<p>Map a message type to its corresponding result type:</p>"},{"type":"code-block","language":"typescript","content":"import { MessageResult } from 'isolated-workers';\n\ntype LoadResultType = MessageResult<Messages, 'load'>;\n// { type: 'loadResult', tx: string, payload: { loaded: true } }","highlightedHtml":"<pre class=\"shiki github-dark\" style=\"background-color:#00000000;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { <a href=\"/isolated-workers/api/message-result\" class=\"code-link\" title=\"View MessageResult documentation\">MessageResult</a> } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'isolated-workers'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LoadResultType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> <a href=\"/isolated-workers/api/message-result\" class=\"code-link\" title=\"View MessageResult documentation\">MessageResult</a></span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Messages</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'load'</span><span style=\"color:#E1E4E8\">>;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// { type: 'loadResult', tx: string, payload: { loaded: true } }</span></span></code></pre>"},{"type":"html","html":"<h3>Middleware Type</h3>\n<p>Middleware function type for intercepting messages:</p>"},{"type":"code-block","language":"typescript","content":"import { Middleware } from 'isolated-workers';\n\nconst logger: Middleware<Messages> = (message, direction) => {\n  console.log(`[${direction}] ${message.type}`);\n  return message;\n};","highlightedHtml":"<pre class=\"shiki github-dark\" style=\"background-color:#00000000;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { <a href=\"/isolated-workers/api/middleware\" class=\"code-link\" title=\"View Middleware documentation\">Middleware</a> } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'isolated-workers'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> logger</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> <a href=\"/isolated-workers/api/middleware\" class=\"code-link\" title=\"View Middleware documentation\">Middleware</a></span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Messages</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">direction</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`[${</span><span style=\"color:#E1E4E8\">direction</span><span style=\"color:#9ECBFF\">}] ${</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">type</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> message;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre>"},{"type":"html","html":"<h3>TransactionIdGenerator Type</h3>\n<p>Type for custom transaction ID generation:</p>"},{"type":"code-block","language":"typescript","content":"import { TransactionIdGenerator } from 'isolated-workers';\n\nconst customTxGen: TransactionIdGenerator<Messages> = (message) => {\n  return `${message.type}-${Date.now()}-${Math.random()}`;\n};","highlightedHtml":"<pre class=\"shiki github-dark\" style=\"background-color:#00000000;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { <a href=\"/isolated-workers/api/transaction-id-generator\" class=\"code-link\" title=\"View TransactionIdGenerator documentation\">TransactionIdGenerator</a> } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'isolated-workers'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> customTxGen</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> <a href=\"/isolated-workers/api/transaction-id-generator\" class=\"code-link\" title=\"View TransactionIdGenerator documentation\">TransactionIdGenerator</a></span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Messages</span><span style=\"color:#E1E4E8\">> </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#9ECBFF\"> `${</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">type</span><span style=\"color:#9ECBFF\">}-${</span><span style=\"color:#E1E4E8\">Date</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#9ECBFF\">()</span><span style=\"color:#9ECBFF\">}-${</span><span style=\"color:#E1E4E8\">Math</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#B392F0\">random</span><span style=\"color:#9ECBFF\">()</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre>"},{"type":"html","html":"<h2>Request/Response Flow</h2>\n<p>Here is how a typical request flows through the system:</p>"},{"type":"code-block","language":"text","content":"HOST                                          WORKER\n────                                          ──────\n  │                                              │\n  │  1. Call worker.send('compute', data)        │\n  │                                              │\n  │  2. Generate transaction ID (tx: \"abc123\")   │\n  │                                              │\n  │  3. Create pending promise for tx            │\n  │                                              │\n  │  4. Serialize message                        │\n  │     { type: 'compute',                       │\n  │       payload: data,                         │\n  │       tx: 'abc123' }                         │\n  │                                              │\n  │  5. Send over socket ──────────────────────► │\n  │                                              │\n  │                        6. Deserialize message│\n  │                                              │\n  │                        7. Lookup handler for │\n  │                           type 'compute'     │\n  │                                              │\n  │                        8. Execute handler    │\n  │                           with payload       │\n  │                                              │\n  │                        9. Handler returns    │\n  │                           result payload     │\n  │                                              │\n  │                       10. Wrap result:       │\n  │                           { type: 'computeResult',\n  │                             payload: result, │\n  │                             tx: 'abc123' }   │\n  │                                              │\n  │ ◄──────────────────── 11. Send over socket   │\n  │                                              │\n  │ 12. Deserialize message                      │\n  │                                              │\n  │ 13. Match tx to pending promise              │\n  │                                              │\n  │ 14. Resolve promise with result              │\n  │                                              │\n  │ 15. Return result to caller                  │\n  │                                              │\n  ▼                                              ▼","highlightedHtml":"<pre class=\"shiki github-dark\" style=\"background-color:#00000000;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span>HOST                                          WORKER</span></span>\n<span class=\"line\"><span>────                                          ──────</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │  1. Call worker.send('compute', data)        │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │  2. Generate transaction ID (tx: \"abc123\")   │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │  3. Create pending promise for tx            │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │  4. Serialize message                        │</span></span>\n<span class=\"line\"><span>  │     { type: 'compute',                       │</span></span>\n<span class=\"line\"><span>  │       payload: data,                         │</span></span>\n<span class=\"line\"><span>  │       tx: 'abc123' }                         │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │  5. Send over socket ──────────────────────► │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │                        6. Deserialize message│</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │                        7. Lookup handler for │</span></span>\n<span class=\"line\"><span>  │                           type 'compute'     │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │                        8. Execute handler    │</span></span>\n<span class=\"line\"><span>  │                           with payload       │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │                        9. Handler returns    │</span></span>\n<span class=\"line\"><span>  │                           result payload     │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │                       10. Wrap result:       │</span></span>\n<span class=\"line\"><span>  │                           { type: 'computeResult',</span></span>\n<span class=\"line\"><span>  │                             payload: result, │</span></span>\n<span class=\"line\"><span>  │                             tx: 'abc123' }   │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │ ◄──────────────────── 11. Send over socket   │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │ 12. Deserialize message                      │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │ 13. Match tx to pending promise              │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │ 14. Resolve promise with result              │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  │ 15. Return result to caller                  │</span></span>\n<span class=\"line\"><span>  │                                              │</span></span>\n<span class=\"line\"><span>  ▼                                              ▼</span></span></code></pre>"},{"type":"html","html":"<h3>Timeout Handling</h3>\n<p>Each pending transaction has an associated timeout. If the worker does not respond within the timeout period:</p>\n<ol>\n<li>The pending promise is rejected with a timeout error</li>\n<li>The transaction is removed from the pending map</li>\n<li>The worker continues running (it may still process the request)</li>\n</ol>\n<p>This prevents indefinite hangs when workers become unresponsive.</p>\n<p>The default timeout is 5 minutes.</p>\n<h2>Server-Side Startup Data</h2>\n<p>When a worker starts, it can receive startup data from the host to initialize its state. This is useful for passing configuration, database connections, or other initialization data:</p>"},{"type":"code-block","language":"typescript","content":"// Host side\nconst worker = await createWorker<Messages>({\n  script: './worker.js',\n  startupData: {\n    config: { apiEndpoint: 'https://api.example.com' },\n    dbConnectionString: 'postgresql://localhost/mydb',\n  },\n});","highlightedHtml":"<pre class=\"shiki github-dark\" style=\"background-color:#00000000;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Host side</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> worker</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#B392F0\"> <a href=\"/isolated-workers/api/create-worker\" class=\"code-link\" title=\"View createWorker documentation\">createWorker</a></span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Messages</span><span style=\"color:#E1E4E8\">>({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  script: </span><span style=\"color:#9ECBFF\">'./worker.js'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  startupData: {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config: { apiEndpoint: </span><span style=\"color:#9ECBFF\">'https://api.example.com'</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dbConnectionString: </span><span style=\"color:#9ECBFF\">'postgresql://localhost/mydb'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span></code></pre>"},{"type":"code-block","language":"typescript","content":"// Worker side\nimport { startWorkerServer } from 'isolated-workers';\n\n// Access startup data via getStartupData()\nconst startupData = getStartupData<{ config: { apiEndpoint: string } }>();\n\nconsole.log('Starting with config:', startupData.config.apiEndpoint);\n\nstartWorkerServer<Messages>({\n  handlers: {\n    fetchData: async () => {\n      // Use configuration from startup data\n      const response = await fetch(startupData.config.apiEndpoint);\n      return response.json();\n    },\n  },\n});","highlightedHtml":"<pre class=\"shiki github-dark\" style=\"background-color:#00000000;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Worker side</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { <a href=\"/isolated-workers/api/start-worker-server\" class=\"code-link\" title=\"View startWorkerServer documentation\">startWorkerServer</a> } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'isolated-workers'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Access startup data via getStartupData()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> startupData</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> getStartupData</span><span style=\"color:#E1E4E8\">&#x3C;{ </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#FFAB70\">apiEndpoint</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\"> } }>();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Starting with config:'</span><span style=\"color:#E1E4E8\">, startupData.config.apiEndpoint);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\"><a href=\"/isolated-workers/api/start-worker-server\" class=\"code-link\" title=\"View startWorkerServer documentation\">startWorkerServer</a></span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">Messages</span><span style=\"color:#E1E4E8\">>({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  handlers: {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fetchData</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">async</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Use configuration from startup data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> response</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#B392F0\"> fetch</span><span style=\"color:#E1E4E8\">(startupData.config.apiEndpoint);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> response.</span><span style=\"color:#B392F0\">json</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span></code></pre>"},{"type":"html","html":"<p><strong>Key points about startup data</strong>:</p>\n<ul>\n<li>Sent during the initial handshake, before any messages</li>\n<li>Available immediately when the worker server starts</li>\n<li>Serialized and deserialized like regular messages</li>\n<li>Useful for one-time initialization that doesn't need to be in every message</li>\n</ul>\n<h2>Key Terminology</h2>\n<h3>Host</h3>\n<p>The main Node.js process that spawns and manages workers. The host sends requests to workers and receives results.</p>\n<h3>Worker</h3>\n<p>A child Node.js process spawned by the host. Workers register handlers for message types and process incoming requests independently.</p>\n<h3>Handler</h3>\n<p>A function in the worker that processes a specific message type. Handlers receive the message payload and return a result payload (or nothing for fire-and-forget messages).</p>\n<h3>Payload</h3>\n<p>The data portion of a message. Request payloads are sent from host to worker; result payloads are returned from worker to host.</p>\n<h3>Result</h3>\n<p>The response data returned by a handler. Results are automatically wrapped in a result message and sent back to the host.</p>\n<h3>Transaction ID (tx)</h3>\n<p>A unique identifier linking a request to its response. Generated for each send operation and included in both the request and response messages.</p>\n<h3>Message Type</h3>\n<p>The string identifier for a category of messages (e.g., 'compute', 'load', 'shutdown'). Each message type has a corresponding handler in the worker.</p>\n<h3>Socket</h3>\n<p>The communication channel between host and worker. Uses Unix domain sockets on Unix-like systems and named pipes on Windows.</p>\n<h3>Middleware</h3>\n<p>An optional function that can intercept and transform messages in either direction (sending or receiving). Useful for logging, validation, or adding metadata.</p>\n<h3>Serializer</h3>\n<p>The component responsible for converting messages to a transmittable format (and back). Default is JSON, but can be customized for binary formats or compression.</p>\n<h3>Lifecycle</h3>\n<p>The stages a worker goes through: spawn (create process), connect (establish socket), message (exchange data), and shutdown (cleanup and exit).</p>\n<h2>Next Steps</h2>\n<p>Now that you understand the core concepts, explore:</p>\n<ul>\n<li><a href=\"/isolated-workers/docs/concepts/why-isolated-workers\">Why isolated-workers?</a> - When and why to use this library</li>\n<li><a href=\"/isolated-workers/docs/getting-started\">Getting Started</a> - Create your first worker</li>\n<li><a href=\"/isolated-workers/docs/guides\">Guides</a> - Deep dives into specific topics</li>\n<li><a href=\"/isolated-workers/examples\">Examples</a> - Working code examples</li>\n</ul>"}]}}