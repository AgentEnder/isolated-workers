# Phase 3b: TypeDoc with Liquid Tags Integration

## Overview

Add liquid tag support to our markdown documentation system, enabling accurate type references that are automatically synced with the codebase via typedoc. This ensures documentation stays in sync with implementation and provides clickable type links.

## Why This Plan?

Documentation currently has accuracy issues with:
- Hardcoded API references that can become outdated
- Manual type documentation that drifts from source code
- No easy way to verify type names match actual exports
- Dead links when types are renamed or moved

Typedoc provides JSON output from source code. Liquid tags would bridge typedoc data with our markdown system, creating:
- **Live type references** that update automatically when code changes
- **Clickable links** to full type definitions
- **Syntax-highlighted signatures** from actual source code
- **Accurate parameters** that match function signatures exactly

## Dependencies

- typedoc package already configured (`typedoc.json`)
- Comprehensive implementation plan exists (`10-typedoc-api-reference.md`)
- Markdown processing infrastructure in place (`docs-site/server/utils/markdown.ts`)
- Liquid tag system in place (`docs-site/server/utils/liquid-tags.ts`)

## Key Requirements

### Functional Requirements

- Parse typedoc JSON output and convert to liquid-friendly format
- Create liquid tag `apireference` that accepts module and export names
- Update markdown processing to handle `apireference` tags
- Generate type-safe HTML rendering with links to documentation
- Preserve existing markdown processing (file includes, code blocks, etc.)
- Support JSDoc block rendering from typedoc data

### Non-Functional Requirements

- Keep liquid tags lightweight and readable
- Provide fallback when typedoc type not found
- Generate on server startup (dev mode only)
- Don't require manual rebuilds of documentation

## Success Criteria

- [ ] `{% typedoc export:module %}` tag renders as type reference
- [ ] `{% typedoc export:module:export %}` tag renders as export reference
- [ ] Type references link to full type documentation
- [ ] Typedoc tags processed during markdown phase (with proper error handling)
- [ ] TypeDoc JSON generated by running `npx typedoc` and checked into .gitignore
- [ ] Type references render with accurate signatures and links
- [ ] Manual testing confirms type references work correctly

---

# Implementation Phases

## Phase 1: Liquid Tag Extensions (Backend)

### Task 1.1: Extend Liquid Tag System

**File**: `docs-site/server/utils/liquid-tags.ts`

**Additions**:
```typescript
export interface ApiReferenceTag extends LiquidTag {
  /**
   * API reference tag with type information.
   * Syntax: {% typedoc export:module %} or {% typedoc export:module:export %}
   */
  kind: 'typedoc-export';
  module?: string;        // Module name (e.g., "core", "types")
  exportName?: string;   // Export name (e.g., "createWorker", "Handlers")
}

export type LiquidTag = LiquidTag | ApiReferenceTag;

/**
 * Parse a typedoc API reference tag.
 * Syntax: {% typedoc export:module %} or {% typedoc export:module:export %}
 */
export function parseTypedocTag(
  text: string
): ApiReferenceTag | null {
  const match = text.match(/^typedoc:export:([\w.-]+)(?::([\w.-]+))?$/);

  if (!match) {
    return null;
  }

  return {
    isPlaceholder: true,
    tag: {
      type: 'typedoc-export',
      name: match[1],
      attributes: {
        module: match[1],
        ...(match[2] ? { export: match[2] } : {}),
      },
    },
  };
}
```

### Task 1.2: Update Markdown Processing

**File**: `docs-site/server/utils/markdown.ts`

**Modifications**:
```typescript
import type { LiquidTag } from './liquid-tags';

/**
 * Process markdown with typedoc API reference tags.
 * Replace typedoc tags with type-safe HTML links.
 */
export function processMarkdownWithTypedoc(
  markdown: string,
  options: ProcessMarkdownChunkOptions = {}
): string {
  // Add typedoc export type to options
  const optionsWithTypedoc: ProcessMarkdownChunkOptions = {
    ...options,
    liquidTags: {
      ...options.liquidTags,
      /**
       * Replace typedoc export tags with type-safe links.
       * Links point to /api/:module/:export pages.
       */
      typedoc: (text: string) => {
        const match = text.match(/^typedoc:export:([\w.-]+)(?::([\w.-]+))?$/);
        if (!match) return null;

        const [, module, export] = match;
        const exportName = export ? `export:${export}` : '';

        return {
          isPlaceholder: true,
          tag: {
            type: 'typedoc-export',
            name: match[1],
            attributes: {
              module: match[1],
              ...(export ? { export } : {}),
            },
            content: {
              tag: 'typedoc-export-replacement',
              module: match[1] || '',
              ...(export ? { export } : {}),
            },
          },
        };
      },
    },
  };

  return parseMarkdown(markdown, optionsWithTypedoc);
}
```

---

## Phase 2: Markdown Processing with Typedoc Lookup

### Task 2.1: Handle Typedoc Tags During Markdown Processing

**File**: `docs-site/server/utils/markdown.ts`

**Modifications**:
```typescript
import type { LiquidTag } from './liquid-tags';

/**
 * Process markdown with typedoc API reference tags.
 * Look up typedoc data and replace tags with type-safe links.
 */
export function processMarkdownWithTypedoc(
  markdown: string,
  options: ProcessMarkdownChunkOptions = {}
): string {
  // Add typedoc export type to options
  const optionsWithTypedoc: ProcessMarkdownChunkOptions = {
    ...options,
    liquidTags: {
      ...options.liquidTags,
      /**
       * Handle typedoc export tags during markdown processing.
       * Load typedoc JSON, look up type/export, replace with link.
       * Error gracefully if typedoc unavailable or type not found.
       */
      typedoc: async (text: string) => {
        const tag = parseTypedocTag(text);
        if (!tag) return null;

        const [, module, export] = [tag.attributes.module, tag.attributes.export].filter(Boolean);
        const exportName = export ? export : null;

        // Try to load typedoc data
        let typedocJson: TypeDocJson | null = null;
        try {
          const workspaceRoot = path.resolve(process.cwd(), '..', '..');
          const jsonPath = path.join(workspaceRoot, '.typedoc/api.json');
          await fs.access(jsonPath);
          const jsonContent = await fs.readFile(jsonPath, 'utf-8');
          typedocJson = JSON.parse(jsonContent);
        } catch (err) {
          // typedoc.json not available - render without type reference
          console.warn(`[typedoc] JSON not found at ${jsonPath}. Type reference will not be linked.`);
          return null;
        }

        // Build type documentation link
        let typeLink = null;
        if (typedocJson && exportName) {
          // Find the type/export in typedoc data
          const moduleData = typedocJson.modules?.[module];
          if (!moduleData) {
            console.warn(`[typedoc] Module "${module}" not found in typedoc data`);
            return null;
          }

          const typeEntry = moduleData.exports?.find(e => exportName ? e.name === exportName : false);
          if (!typeEntry) {
            console.warn(`[typedoc] Type "${exportName}" not found in module "${module}"`);
            return null;
          }

          // Build link to type documentation
          const basePath = `/api/${module}`;
          const exportPath = exportName ? `${basePath}/${exportName}` : basePath;
          typeLink = `<a href="${exportPath}" class="hover:text-neon-cyan" title="View full type documentation">${exportName}</a>`;
        }

        return {
          isPlaceholder: true,
          tag: {
            type: 'typedoc-export-replacement',
            module: module || '',
            ...(exportName ? { export: exportName } : {}),
          },
          content: typeLink || `<span class="text-gray-300">${exportName || export}</span>`,
        };
      },
    },
  };

  return parseMarkdown(markdown, optionsWithTypedoc);
}
```

        // Build type documentation link
        let typeLink = null;
        if (typedocJson && exportName) {
          // Find the type/export in typedoc data
          const moduleData = typedocJson.modules?.[module];
          if (!moduleData) {
            console.warn(`[typedoc] Module "${module}" not found in typedoc data`);
            return null;
          }

          const typeEntry = moduleData.exports?.find(e => exportName ? e.name === exportName : false);
          if (!typeEntry) {
            console.warn(`[typedoc] Type "${exportName}" not found in module "${module}"`);
            return null;
          }

          // Build link to type documentation
          const basePath = `/api/${module}`;
          const exportPath = exportName ? `${basePath}/${exportName}` : basePath;
          typeLink = `<a href="${exportPath}" class="hover:text-neon-cyan" title="View full type documentation">${exportName}</a>`;
        }

        return {
          isPlaceholder: true,
          tag: {
            type: 'typedoc-export-replacement',
            module: module || '',
            ...(exportName ? { export: exportName } : {}),
          },
          content: typeLink || `<span class="text-gray-300">${exportName || export}</span>`,
        };
      },
    },
  };

  return parseMarkdown(markdown, optionsWithTypedoc);
}
```

**File**: `docs-site/server/utils/typedoc.ts` (or extend existing)

**Modifications** (extend existing typedoc parsing):
```typescript
import { execSync } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';

// Extend existing interface to include typedoc data
export interface TypedocData {
  modules: Record<string, ApiModule>;
  exports: Record<string, ApiExport>;
  allExports: ApiExport[];
  typedoc?: TypeDocJson;  // Add typedoc raw data
}

export interface ApiExport {
  // ... existing fields ...
  typedocModule?: string;  // Module this export belongs to
  typedocPath?: string;      // Path to typedoc JSON for this export
}

export interface ApiModule {
  // ... existing fields ...
  typedocPath?: string;  // Path to typedoc JSON for this module
  }
```

## Phase 3: Frontend Rendering

### Task 3.1: Create Type Reference Component

**New File**: `docs-site/components/TypeReference.tsx`

```typescript
import type { ApiExport } from '../../server/utils/typedoc';

export interface TypeReferenceProps {
  export: ApiExport;
}

export function TypeReference({ export }: TypeReferenceProps) {
  const { typedocPath, typedocModule } = export;

  if (!typedocPath) {
    return <span className="text-gray-300">{export.name}</span>;
  }

  // Build path to type documentation
  const basePath = `/api/${typedocModule || 'core'}`;
  const exportPath = export.name ? `${basePath}/${export.name}` : basePath;

  return (
    <Link
      href={exportPath}
      className="hover:text-neon-cyan transition-colors"
      title="View full type documentation"
    >
      {export.name}
    </Link>
  );
}
```

### Task 3.2: Create TypedocBlock Component

**New File**: `docs-site/components/TypedocBlock.tsx`

```typescript
import type { ApiExport } from '../../server/utils/typedoc';
import { CodeBlock } from './CodeBlock';

export interface TypedocBlockProps {
  export: ApiExport;
}

export function TypedocBlock({ export }: TypedocBlockProps) {
  const { typedocPath, typedocModule } = export;

  if (!typedocPath || !export.comment) {
    return null;
  }

  // Render signature with typedoc data
  const signature = export.typedocModule
    ? export.signature?.replace(/\\s*\\(\\w+\\)/g, (match, name) => {
        // Replace backslash-escaped words with links
        const typedocPath = export.typedocModule;
        if (typedocPath) {
          return `<a href="/api/${typedocPath}" class="hover:text-neon-cyan">${name}</a>`;
        }
        return match;
      })
    : export.signature;

  return (
    <div className="mb-4">
      <div className="flex items-center gap-2">
        <span className="text-xs px-2 py-1 rounded bg-neon-cyan/20 text-neon-cyan uppercase font-semibold">
          Type Reference
        </span>
        {export.comment?.deprecated && (
          <span className="text-xs px-2 py-1 rounded bg-red-500/10 text-red-400 uppercase font-semibold">
            Deprecated
          </span>
        )}
      </div>

      {signature && (
        <div className="mb-4">
          <CodeBlock code={signature} language="typescript" />
        </div>
      )}

      {/* Render description, parameters, etc. from typedoc data */}
      {export.description && (
        <p className="text-gray-300 text-lg">{export.description}</p>
      )}

      {export.parameters && export.parameters.length > 0 && (
        <div className="mb-8">
          <h2 className="text-xl font-semibold text-gray-100 mb-4">Parameters</h2>
          {export.parameters.map((param, i) => (
            <div key={i} className="mb-4">
              <h3 className="text-lg font-semibold text-gray-200 mb-2">
                {param.name}
                {param.optional && (
                  <span className="text-xs px-2 py-1 rounded bg-secondary/50 text-gray-300">
                    optional
                  </span>
                )}
              </h3>

              {param.type && (
                <div className="mb-2">
                  <span className="text-sm text-gray-500 font-mono">
                    {param.type}
                  </span>
                </div>
              )}

              {param.defaultValue && (
                <div className="mb-2">
                  <span className="text-sm text-gray-400 mb-1">Default:</span>{' '}
                  <span className="text-sm text-gray-500 font-mono">
                    {param.defaultValue}
                  </span>
                </div>
              )}

              {param.description && (
                <p className="text-gray-400">{param.description}</p>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

### Task 3.3: Update ApiExport Component

**File**: `docs-site/pages/api/components/ApiExport.tsx`

**Modifications**: Add TypeReference component usage

```typescript
// Add import
import { TypeReference } from './TypeReference';

// Update export display to include type reference link
export function ApiExportPage({ export }: ApiExportPageProps) {
  // ... existing code ...

  return (
    <div>
      {/* ... existing header ... */}

      <div className="flex items-center gap-3 mb-4">
        <h1 className="text-4xl font-bold text-gray-900 mb-2">
          {export.name}
        </h1>

        {/* Add type reference link if typedoc data available */}
        {export.typedocPath && (
          <TypeReference export={export} />
        )}

        {/* ... rest of signature section ... */}
      </div>

      {/* ... rest of component ... */}
    </div>
  );
}
```

### Task 3.4: Update ApiModule Component

**File**: `docs-site/pages/api/components/ApiModule.tsx`

**Modifications**: Add TypeReference links for exports

```typescript
// Add TypeReference imports and usage
import { TypeReference } from './TypeReference';

// Update export list rendering to include type references
export function ApiModulePage({ module }: ApiModulePageProps) {
  // ... existing code ...

  return (
    <div>
      {/* ... header ... */}

      {/* ... existing exports list ... */}
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {module.exports.map((exp, i) => (
          <Link
            key={exp.name}
            href={exp.path}
            className="block p-6 rounded-xl bg-tertiary/50 border border-tertiary/50 hover:bg-tertiary/50 transition-all group"
          >
            <div className="flex items-center gap-2">
              {/* ... existing icon and name ... */}

              {/* Add type reference link */}
              {exp.typedocPath && (
                <div className="ml-2">
                  <TypeReference export={exp} />
                </div>
              )}

              {/* ... existing description ... */}
            </div>

            {/* ... existing type/parameter badges ... */}
          </Link>
        ))}
      </div>

      {/* ... rest of component ... */}
    </div>
  );
}
```

---

## Phase 4: Testing & Validation

### Task 4.1: Test Liquid Tags

Create test file: `docs-site/server/utils/liquid-tags.test.ts`

```typescript
import { parseTypedocTag } from './liquid-tags';

describe('parseTypedocTag', () => {
  it('parses module export', () => {
    const result = parseTypedocTag('typedoc:export:createWorker');
    expect(result).toEqual({
      isPlaceholder: true,
      tag: {
        type: 'typedoc-export',
        name: 'createWorker',
        attributes: { module: 'core' },
      },
    });
  });

  it('parses export with export name', () => {
    const result = parseTypedocTag('typedoc:export:types:DefineMessages');
    expect(result).toEqual({
      isPlaceholder: true,
      tag: {
        type: 'typedoc-export',
        name: 'types',
        attributes: {
          module: 'types',
          export: 'DefineMessages',
        },
      },
    });
  });

  it('returns null for non-matching', () => {
    const result = parseTypedocTag('regular text');
    expect(result).toBeNull();
  });
});
```

### Task 4.2: Test Markdown Processing

Update existing markdown tests to verify typedoc handling.

### Task 4.3: Manual Testing

Test with real typedoc output:
1. Generate typedoc JSON: `cd .. && npx typedoc`
2. Start dev server: `cd docs-site && pnpm dev`
3. Visit `/api` - should show all modules with type references
4. Visit `/api/core/createWorker` - should show createWorker with signature
5. Click type links - should navigate to full type documentation

---

## Edge Cases

- **typedoc.json doesn't exist**: Should render exports without type links (fallback to plain text), log warning
- **typedoc.json available but export not found**: Should log warning, render without link, suggest running `npx typedoc`
- **Type renamed in code**: TypeDoc will update automatically, links will point to new location
- **Export removed from API**: Link should show "not found" state
- **Module path mismatch**: Should log warning but still attempt to render
- **Multiple type definitions**: Display all available, most recent wins

**Important**: typedoc.json must be regenerated manually after code changes with:
```bash
cd /path/to/repo && npx typedoc
```
The markdown processor will then pick up the updated type data on the next server restart.

## Open Questions

1. Should we preserve the manual API docs as fallback when typedoc is unavailable?
2. How should we handle type references for internal/private types?
3. Should we add a "View Source" button linking to GitHub?
4. Should we cache the typedoc JSON more aggressively (in memory vs filesystem)?

# Research References

- Existing typedoc plan: `.ai/plans/10-typedoc-api-reference.md`
- Typedoc documentation: https://typedoc.org/
- Liquid tag documentation in existing codebase

# Success Criteria

- [ ] Liquid tag system extended with typedoc-export support
- [ ] Markdown processing updated to handle typedoc tags
- [ ] TypeReference component created and renders clickable links
- [ ] TypedocBlock component renders full type documentation
- [ ] Server loads typedoc JSON into global context
- [ ] Type references link to documentation pages
- [ ] All tests pass
- [ ] Manual testing confirms type references work correctly

---

# Notes

- This builds on existing typedoc plan infrastructure
- TypeDoc JSON must exist (generated manually with `npx typedoc`)
- Liquid tags provide clean, readable syntax for docs authors
- Links use /api/:module/:export routing that matches typedoc data structure
- Fallback to static docs when typedoc unavailable
- Dev-time regeneration (server restart) means docs stay in sync
- typedoc.json should be regenerated after code changes that modify types

**Manual Typedoc Generation**:
typedoc.json is not automatically generated. After code changes that modify public types:
1. Run `cd /path/to/repo && npx typedoc`
2. Type references in markdown will pick up the new data on next server restart
3. Commit the updated `.typedoc/api.json` file (or add to .gitignore if not committing)

---

# Benefits

**Accurate Documentation**: Type references automatically sync with source code
**Better UX**: Clickable links to full type definitions
**Maintainability**: No manual doc updates needed for type changes
**Type Safety**: Links always point to current type definitions
**Developer Friendly**: Simple syntax: `{% typedoc export:module %}`
